<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Snapgram â€” Full HD Video + Audio</title>
<link rel="icon" href="data:,">
<style>
  :root{--btn-size:84px;}
  html,body{height:100%;margin:0;background:#000;font-family:Arial,Helvetica,sans-serif}
  /* preview canvas that fills screen (cover-like) */
  #preview {
    position:fixed; inset:0;
    width:100vw; height:100vh;
    display:block;
    background:#000;
    touch-action:none;
  }
  #captureBtn{
    position:fixed; bottom:28px; left:50%; transform:translateX(-50%);
    width:var(--btn-size); height:var(--btn-size); border-radius:50%;
    background:rgba(255,255,255,0.95); border:6px solid rgba(255,255,255,0.7);
    z-index:50; box-shadow:0 6px 18px rgba(0,0,0,0.4); -webkit-tap-highlight-color: transparent;
  }
  #flipBtn{position:fixed; top:22px; right:18px; z-index:60; padding:8px 12px; border-radius:20px; background:rgba(0,0,0,0.45); color:#fff; border:1px solid rgba(255,255,255,0.15); font-weight:600;}
  #progressOverlay { position:fixed; left:0; right:0; bottom:140px; text-align:center; color:#fff; z-index:60; display:none; }
  #progressOverlay .box { background: rgba(0,0,0,0.6); display:inline-block; padding:10px 14px; border-radius:10px; font-size:14px; }
  video{display:none}
</style>
</head>
<body>

<!-- Hidden video source, visible preview is canvas -->
<video id="video" autoplay playsinline muted></video>
<canvas id="preview"></canvas>

<!-- Frame image (1080x1920) - ensure this file exists -->
<img id="frameImg" src="frame.png" alt="frame" style="display:none;" />

<button id="captureBtn" aria-label="Capture"></button>
<button id="flipBtn">Flip</button>

<div id="progressOverlay"><div class="box" id="progressText">Loading...</div></div>

<!-- ffmpeg.wasm -->
<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.4/dist/ffmpeg.min.js"></script>

<script>
/*
  Full script:
  - Photo: 1080x1920 JPG (procCanvas)
  - Video: capture from procCanvas + mic -> MediaRecorder (webm) -> convert to mp4 with ffmpeg.wasm
  - Tap = photo, Hold = record (touch & mouse)
*/

const preview = document.getElementById('preview');
const video = document.getElementById('video');
const frameImg = document.getElementById('frameImg');
const captureBtn = document.getElementById('captureBtn');
const flipBtn = document.getElementById('flipBtn');
const progressOverlay = document.getElementById('progressOverlay');
const progressText = document.getElementById('progressText');

let usingFront = false;
let stream = null;
let micStream = null;
let cameraReady = false;

const OUT_W = 1080, OUT_H = 1920; // forced output size

// processing canvas (fixed output)
const procCanvas = document.createElement('canvas');
procCanvas.width = OUT_W; procCanvas.height = OUT_H;
const procCtx = procCanvas.getContext('2d');

// preview canvas (fills screen)
function fitPreview(){ preview.width = window.innerWidth; preview.height = window.innerHeight; }
fitPreview(); window.addEventListener('resize', fitPreview);
const pctx = preview.getContext('2d');

// preview draw loop
let animHandle = null;
function drawFrameToProc() {
  if (!cameraReady) return;
  const vW = video.videoWidth || OUT_W;
  const vH = video.videoHeight || OUT_H;
  const vRatio = vW / vH;
  const tRatio = OUT_W / OUT_H;

  let sx=0, sy=0, sw=vW, sh=vH;

  if (vRatio > tRatio) {
    // crop left/right
    sw = vH * tRatio;
    sx = (vW - sw) / 2;
  } else {
    // crop top/bottom
    sh = vW / tRatio;
    sy = (vH - sh) / 2;
  }

  procCtx.clearRect(0,0,OUT_W,OUT_H);
  procCtx.drawImage(video, sx, sy, sw, sh, 0,0, OUT_W, OUT_H);

  if (frameImg.complete) {
    procCtx.drawImage(frameImg, 0,0, OUT_W, OUT_H);
  }

  // draw procCanvas to preview canvas with cover behavior
  const pvW = preview.width, pvH = preview.height;
  const pvRatio = pvW / pvH;
  const procRatio = OUT_W / OUT_H;

  let srcX=0, srcY=0, srcW=OUT_W, srcH=OUT_H;
  if (procRatio > pvRatio) {
    // crop left-right
    srcW = OUT_H * pvRatio;
    srcX = (OUT_W - srcW) / 2;
  } else {
    srcH = OUT_W / pvRatio;
    srcY = (OUT_H - srcH) / 2;
  }

  pctx.clearRect(0,0,pvW,pvH);
  pctx.drawImage(procCanvas, srcX, srcY, srcW, srcH, 0,0, pvW, pvH);
}

function startPreviewLoop() {
  if (animHandle) return;
  function loop(){ drawFrameToProc(); animHandle = requestAnimationFrame(loop); }
  loop();
}

// camera start
async function startCamera() {
  cameraReady = false;
  if (stream) { stream.getTracks().forEach(t=>t.stop()); stream=null; }
  if (micStream) { micStream.getTracks().forEach(t=>t.stop()); micStream=null; }

  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: usingFront ? 'user' : 'environment', width:{ideal:1920}, height:{ideal:3840} },
      audio: false
    });

    // mic (we'll request audio when starting recording to reduce prompts)
    // micStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });

    video.srcObject = stream;
    await new Promise(r => {
      if (video.readyState >= 2) r(); else video.onloadedmetadata = r;
    });

    cameraReady = true;
    startPreviewLoop();

  } catch (err) {
    console.error('startCamera error', err);
    alert('Gagal mengakses kamera: ' + err.message);
  }
}

// PHOTO function
function downloadDataURL(url, name){
  const a = document.createElement('a'); a.href = url; a.download = name; a.click();
}

function takePhoto() {
  if (!cameraReady) return;
  // ensure a fresh draw
  drawFrameToProc();
  const dataUrl = procCanvas.toDataURL('image/jpeg', 0.92);
  downloadDataURL(dataUrl, 'photo_1080x1920.jpg');
}

// RECORDING WITH AUDIO
let mediaRecorder = null;
let recordedChunks = [];

// load ffmpeg lazily (first time conversion)
const { createFFmpeg, fetchFile } = FFmpeg;
const ffmpeg = createFFmpeg({ log: true });

async function ensureFFmpegLoaded() {
  if (!ffmpeg.isLoaded()) {
    progressOverlay.style.display = 'block';
    progressText.textContent = 'Loading FFmpeg (itu besar, tunggu sebentar)...';
    await ffmpeg.load();
    progressOverlay.style.display = 'none';
  }
}

// start recording: capture canvas stream + microphone
async function startRecording() {
  if (!cameraReady || mediaRecorder) return;

  try {
    // request mic now
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });

    // capture video frames from procCanvas (OUT_W x OUT_H at 25 fps)
    const canvasStream = procCanvas.captureStream(25); // fps
    // combine tracks
    const combined = new MediaStream();
    canvasStream.getVideoTracks().forEach(t => combined.addTrack(t));
    micStream.getAudioTracks().forEach(t => combined.addTrack(t));

    // MediaRecorder (webm)
    const options = { mimeType: 'video/webm;codecs=vp8,opus' };
    mediaRecorder = new MediaRecorder(combined, options);

    recordedChunks = [];
    mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) recordedChunks.push(e.data); };

    mediaRecorder.onstart = () => {
      progressOverlay.style.display = 'block';
      progressText.textContent = 'Merekam...';
    };

    mediaRecorder.onstop = async () => {
      progressText.textContent = 'Mengonversi ke MP4...';
      const webmBlob = new Blob(recordedChunks, { type: 'video/webm' });

      try {
        await ensureFFmpegLoaded();

        // write file to ffmpeg FS
        ffmpeg.FS('writeFile', 'input.webm', await fetchFile(webmBlob));

        // run conversion: webm (vp8/opus) -> mp4 (h264+aac)
        // -preset veryfast for speed; slower presets yield better compression
        await ffmpeg.run(
          '-i', 'input.webm',
          '-c:v', 'libx264', '-preset', 'veryfast',
          '-c:a', 'aac', '-b:a', '128k',
          '-movflags', 'faststart',
          'output.mp4'
        );

        const data = ffmpeg.FS('readFile', 'output.mp4');
        const mp4Blob = new Blob([data.buffer], { type: 'video/mp4' });

        const url = URL.createObjectURL(mp4Blob);
        downloadDataURL(url, 'video_1080x1920_with_audio.mp4');

        // cleanup ffmpeg FS to free memory
        try { ffmpeg.FS('unlink','input.webm'); ffmpeg.FS('unlink','output.mp4'); } catch(e){}

      } catch (e) {
        console.error('Konversi gagal', e);
        alert('Gagal mengonversi video: ' + e.message);
      } finally {
        progressOverlay.style.display = 'none';
      }

      // cleanup
      mediaRecorder = null;
      if (micStream) { micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
    };

    mediaRecorder.start();
  } catch (err) {
    console.error('startRecording failed', err);
    alert('Gagal memulai perekaman: ' + err.message);
    progressOverlay.style.display = 'none';
    mediaRecorder = null;
  }
}

// stop recording
function stopRecording() {
  if (!mediaRecorder) return;
  try {
    mediaRecorder.stop();
  } catch (e) { console.warn(e); }
}

// BUTTON interactions (tap vs hold)
let pressTimer = null;
let holding = false;
const HOLD_DELAY = 350;

function pointerDown(e) {
  e.preventDefault();
  holding = false;
  pressTimer = setTimeout(async () => {
    holding = true;
    await startRecording();
  }, HOLD_DELAY);
}

function pointerUp(e) {
  e.preventDefault();
  if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
  if (!holding) {
    takePhoto();
  } else {
    stopRecording();
  }
}

captureBtn.addEventListener('mousedown', pointerDown);
captureBtn.addEventListener('mouseup', pointerUp);
captureBtn.addEventListener('mouseleave', ()=>{ if (pressTimer) clearTimeout(pressTimer); });
captureBtn.addEventListener('touchstart', pointerDown, {passive:false});
captureBtn.addEventListener('touchend', pointerUp);

// flip camera
flipBtn.addEventListener('click', () => {
  usingFront = !usingFront;
  startCamera();
});

// start camera on load
startCamera();

</script>
</body>
</html>
